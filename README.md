# Networks

Практикум по теме "Компьютерные сети". Данный практикум может быть выполнен двумя путями: можно развивать предыдущий практикум AirDefense, а можно будет реализовать совершенно новое приложение-мессенджер.

## Мультиплеер AirDefense

Первым вариантом задания практикума будет реализация мультиплеера для предыдущего задания. Это означает, что приложение необходимо разделить на две части: сервер и клиент. Сервер должен получать от клиентов команды на движение орудя и выстрелы, производить вычисления и отправлять клиентским приложениям координаты всех объектов. Клиентское приложение передает команды серверу и отрисовывает объекты на экране. Важно, что никакой логики на клиенте быть не должно: только сбор и передача команд, получение списка объектов с координатами от сервера и отрисовка. Условимся, что количество игроков в одной игре не превышает 4. Задача -- сбить больше других. Вариантов выполнения на различные оценки у этого задания не будет.

## Мессенджер
Второй вариант задания практикума -- мессенджер, также состоящий из двух приложений: клиентского и серверного. Это задание придется реализовать с нуля. Для него будет доступно несколько вариантов выполнения.
Запуск приложения-сервера:

python3 server.py <ip> <port>


Запуск приложения-клиента:

python3 client.py <ip> <port>



Удовлетворительно (на троечку)

Сервер
Сервер должен работать на уровне TCP. Вам потребуется библиотека socket. Сервер должен иметь возможность подключить до 1000 клиентов. На тройку достаточно будет реализовать известный нам чат-помойку с одним дополнением: аутентификация. Напомню, о чем идет речь: сервер, получая сообщение от клиента печатает на экран ник этого клиента, время сообщения и текст самого сообщения, после чего рассылает эту строку всем клиентам за исключением отправителя. Пример:

gigalol (23:56): Hello, World!


К известной нам структуре добавился ник и аутентификация. Это означает, что при подключении к серверу, он просит клиента представиться и ищет клиента в базе по нику. Если ник обнаружен, клиента просят ввести пароль, далее происходит процедура сверки паролей, если они не совпадают, клиента отключает от сервера, если же все в порядке, клиенту сообщается об успешной аутентификации, он может приступать к общению. Важно! Ни в коем случае нельзя хранить пароль клиента, следует взять от него хэш, например, sha1 и сверять хэши паролей. Хранение паролей в открытом виде -- фу-фу-фу! Если это первое подключение клиента к серверу и его ник не обнаружен, сервер дважды просит его ввести пароль, сверяя результаты, затем сохраняет хэш этого пароля, чтобы аутентифицировать клиента в будущем. Важно, что сервер не должен "зависать" в процессе общения с клиентом и "кидать" всех остальных пользователей. Он должен "запоминать", в каком статусе находится тот или иной клиент и постоянно продолжать обслуживание всех в штатном режиме. Напомню, что параллельное обслуживание нескольких сокетов позволит реализовать библиотека selectors.

Клиент
У клиентсокго приложения две функции: печатать все, что приходит от сервера и отправлять на сервер все, что приходит с клавиатуры. А чтобы эти функции реализовывать параллельно, не прибегая к активному ожиданию, следует также воспользоваться библиотекой selectors.

Хорошо (на четверку)
Введем такое понятие как команда. Команды будут начинаться с символа /. И введем следующий список команд:


/create <name> -- команда создает комнату на сервере с названием <name>. Если имя занято, сервер должен об этом сообщить, если же имя свободно. сервер должен создать комнату и сообщить ее создателю пароль от комнаты.

/join <name> <password> -- команда, позволяющая клиенту войти в комнату, используя пароль, который сервер выдал создателю данной комнаты. Создатель комнаты входит в нее автоматически при создании. При этом клиент как бы покидает основной чат: теперь его сообщения будут видеть только члены комнаты, он также будет видить только сообщения членов комнаты. Как и в случае с аутентификацией клиентов, не следует хранить пароли от комнат в открытом виде, храните хэши.

/exit -- команда, позволяющая покинуть комнату и вернуться в общий чат.

Итак, на четверку необходимо реализовать чат с аутентификацией (как и на "3") с поддержкой всех перечисленных команд. Клиентское приложение ничем отличаться не будет.

Отлично (на пятерку)
Необходимо выполнить все, что требуется на "4" и кое-что улучшить. Дело в том, что сейчас при остановке сервера (неважно, плановой или аварийной), все данные будут утеряны. На "5" потребуется научить сервер сохранять все данные при его штатной остановке. Штатной будем называть остановку в результате получения сигнала SIGINT (приложение получает его, когда мы нажимаем Ctrl+c). Перед остановкой сервер должен сохранить все данные в файл. А при следующем старте сервер должен импортировать данные из файла. Справиться с этим поможет библиотека signal.
